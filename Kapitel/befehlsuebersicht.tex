\documentclass[c_worksheet.tex]{subfiles}

\begin{document}
	
\chapter{Befehlsübersicht} 

\section{Programmstruktur}

In C geschriebene Programme haben eine generelle Struktur die es zu beachten gibt. Diese sieht wie folgt aus

\begin{lstlisting}
 int main(void) {
    <Code>
    return 0;
 }
 \end{lstlisting} 

Die so genannte \emph{main Funktion} ist der Hauptteil des Programms. Wird das Programm gestartet beginnt es genau am Anfang der \emph{main Funktion}. Gibt es keine \emph{main Funktion} weiß der Computer nicht wo er anfangen soll. \\

\textit{return 0;} \\

Dieser Befehl beendet das Programm und die gibt den Zahlenwert \emph{0} an das Betriebssystem zurück. \emph{0} bedeutet hierbei, dass alles in Ordnung war und das Programm korrekt bis zum Ende durchgelaufen ist.



\section{Includes} 

Mit so genannten \emph{includes} kann man anderen Programmcode in sein eigenes Programm einbinden.

\begin{lstlisting}[numbers=none]
#include <<Paketname>>
\end{lstlisting}

Ein Paket das sehr häufig benötigt wird ist \textbf{stdio.h}. Der Name steht dabei für Standard Input/Output. Dieses Paket stellt einige nützliche Befehle für die Ein- und Ausgabe bereit.
Die wichtigsten hierbei sind \textbf{printf} und \textbf{scanf}. Mit ersterem kann Text auf dem Bildschirm dargestellt werden. Und mit letzterem können Eingaben des Benutzers eingelesen werden.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/print.c} 

Dieses Programm gibt auf der Konsole ``Hallo Welt!'' aus. Ohne \textbf{\#include <stdio.h>}, wüsste der Compiler nicht was printf ist.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/scan.c}

Dieses Programm erwartet eine Eingabe von dem Benutzer und speichert diese in der Variable \(x\). 

\section{Variablen}

In Variablen kann man Werte speichern, dafür gibt es verschiedene Typen, unter anderem:

\begin{itemize}
 	\item \textbf{int} - ganze Zahlen
 	\item \textbf{float} - Kommazahlen
 	\item \textbf{double} - Kommazahlen die doppelt so präzise sind (wie \emph{floats})
 	\item \textbf{char} - Textzeichen wie `a' oder `b' 
 \end{itemize} 

Es gibt noch viele andere Typen für Variablen.

Variablen werden nach dem folgenden Schema angelegt

\begin{lstlisting}[numbers=none]
<typ> <name>;
\end{lstlisting}

und können bei ihrer \emph{Initialisierung} direkt einen Wert zugewiesen bekommen.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/variablen.c}

Das Gleichheitszeichen \textbf{=} hat hier nicht die Bedeutung aus der Mathematik. Sondern ist der \textbf{Zuweisungsoperator}. Der Wert rechts des Zuweisungsoperator wird in die Variable links des Zuweisungsoperators hineingeschrieben.\\
\begin{tabbing}
$\Rightarrow$ \=steht eine Variable links von ``='', wird ein neuer Wert in sie hinein geschrieben\\
\>steht eine Variable rechts von ``='', wird ihr aktueller Wert in eine andere Variable hineingeschrieben\\
\end{tabbing}

\subsection{Variablen mit printf ausgeben} 

Möchte man Variablen mit printf ausgeben, muss man dabei beachten, von welchem Typ diese ist. Ein kleines Beispiel verdeutlicht dies.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/print_int.c}

Das \emph{\%i} wird dabei benutzt, weil \(x\) vom typ \emph{int} ist.

\begin{itemize}
	\item \textbf{\%i} - int
	\item \textbf{\%d} - int
	\item \textbf{\%ld} - long int
	\item \textbf{\%f} - float
	\item \textbf{\%lf} - double
	\item \textbf{\%c} - char
	\item \textbf{\%p} - pointer 
\end{itemize}

Für scanf gilt das genau so.

\section{Arithmetik}

In C gibt es viele verschiedene Arithmetische Operatoren, im folgenden einige wichtige

\begin{itemize}
 	\item \textbf{\(+\)} - Addition
 	\item \textbf{\(-\)} - Subtraktion
 	\item \textbf{\(*\)} - Multiplikation
 	\item \textbf{\(/\)} - Division
 	\item \textbf{\%} - Modulo   
 \end{itemize} 

 Diese \emph{arithmetischen Operatoren} können sowohl mit Variablen als auch mit Konstanten genutzt werden.

 \lstinputlisting{CodeSnippets/Befehlsuebersicht/arithmetik.c} 

Um das Programmieren etwas zu erleichtern gibt es folgende Abkürzungen.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/arithmetik_abkuerzungen.c} 



\section{Logische Operatoren} 


Logische Operatoren unterscheiden sich ein wenig von den arithmetischen, die man sonst so kennt. Formeln mit logischen Operatoren evaluieren immer auf einen so genannten \emph{Wahrheitswert}: \textbf{true} oder \textbf{false}. Diese \emph{keywords} gibt es in C aber leider nicht. In C bedeutet die Zahl \(0\) \textbf{true} und alles andere bedeutet \textbf{false}.

Es gibt unter anderem folgende logische Operatoren in C

\begin{itemize}
	\item \textbf{\&\&} - logisches Und
	\item \textbf{||} - logisches Oder
	\item \textbf{!}  - Negation
\end{itemize}

Im folgenden werden die Operatoren mit Wahrheitstabellen veranschaulicht

\begin{figure}[H]
\begin{center}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\begin{tabular}{ c | c | c }
a & b & a \&\& b \\
\hline
\hline
0 & 0 & 0 \\
\hline
0 & 1 & 0 \\
\hline
1 & 0 & 0 \\
\hline
1 & 1 & 1 \\
\end{tabular}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\begin{tabular}{ c | c | c }
a & b & a || b \\
\hline
\hline
0 & 0 & 0 \\
\hline
0 & 1 & 1 \\
\hline
1 & 0 & 1 \\
\hline
1 & 1 & 1 \\
\end{tabular}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\begin{tabular}{ c | c }
a & !a \\
\hline
\hline
0 & 1 \\
\hline
1 & 0 \\
\end{tabular}
\end{subfigure}
\end{center}
\end{figure}


Andere Operatoren, die nicht direkt mit Wahrheitswerten arbeiten aber solche ausgeben sind z.B.

\begin{itemize}
	\item \textbf{>} - größer als
	\item \textbf{<} - kleiner als
	\item \textbf{>=} - größer gleich
	\item \textbf{<=} - kleiner gleich
	\item \textbf{==} - gleich
\end{itemize}

Diese Operatoren werden hauptsächlich bei Bedingungen verwendet

\section{Bedingungen}

Viele Programme sollen ja nicht immer gleich ablaufen, und sich verschieden verhalten, wenn bestimmte Bedingungen eintreten.

Dafür gibt es den \emph{if} Befehle, oder auch den \emph{if else} Befehl. Mit diesem können so genannte \emph{bedingte Sprünge} gemacht werden. Die Synthax sieht wie folgt aus

\begin{lstlisting}[numbers=none]
if(<Bedingung>) {
	<Code>
}
\end{lstlisting}

Dabei wird <Code> nur ausgeführt, wenn <Bedingung> wahr ist.

Als Bedingung können beliebig komplexe Ausdrücke verwendet werden, solange sich diese auf einen \emph{Wahrheitswert} evaluieren.

Korrekte Bedingungen:

\begin{itemize}
	\item \(x > 5\)
	\item \(y == x\)
	\item \(z > x\) \&\& \(z < x\)
	\item \(a\) || \(b\)
\end{itemize}

Ungültige Bedingungen.

\begin{itemize}
	\item \(x * 4\)
	\item \(y = x\)
	\item \(x++\)
\end{itemize}

Es gibt noch eine so genannte \emph{else} Bedingung, die genau dann ausgeführt wird, wenn die Bedingung in dem \emph{if} Befehl falsch ist.

\begin{lstlisting}[numbers=none]
if(<Bedingung>){
	<Code der ausgefuehrt wird wenn die Bedingung stimmt>
}
else{
	<Code der ausgefuehrt wird wenn die Bedingung nicht stimmt>
}
\end{lstlisting}

Damit lassen sich Programme basteln, die sich verschieden Verhalten, je nachdem wie die Umstände so sind.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/bedingungen.c}



\section{Schleifen} 

Manchmal möchte man, dass ein Stück Code mehrfach ausgeführt wird. Geht es nur um 2 oder 3 mal, könnte man das ganze auch einfach mehrfach hinschreiben. Wenn es dann aber um 100, 1000 oder gar 10000 fach geht, macht das ganze eher weniger Spaß. Dazu kommt, dass man oft nicht weiß, wie oft der Code Teil ausgeführt wird.

Die Bedingungen werden dabei exakt wie bei dem \emph{if} Befehl aufgestellt.

Für solche Fälle gibt es so genannte \emph{Schleifen}. C bietet drei verschiedene.

\subsection{For-Schleife}

Die \emph{For-Schleife} verwendet man, wenn man ein Stück Code eine feste Anzahl oft ausführen möchte. Die Anzahl kann dabei variable sein, jedoch fest. \emph{For-Schleifen} nutzen so genannte \emph{Laufvariablen} mit denen man von einem \emph{Startwert} bis zu einem \emph{Endwert} läuft.

\begin{lstlisting}[numbers=none]
for(<Startwert> ; <Abbruchbedingung> ; <Veraenderung>) {
	<Code der mehrfach ausgefuehrt werden soll>
}
\end{lstlisting}

In den so genannten \emph{Kopf} einer \emph{For-Schleife} schreibt man den Wert, bei dem die Zählvariable beginnen soll, die Bedingung bei der aus der Schleife ausgebrochen werden soll und die Art, wie die \emph{Laufvariable} in jedem \emph{Schleifendurchlauf} verändert werden soll.

\lstinputlisting[firstline=1, lastline=9]{CodeSnippets/Befehlsuebersicht/for_schleifen.c} 

Das Programm gibt 10 mal den Wert von \(i\) aus. \(i\) wird dabei in jedem \emph{Schleifendurchlauf} um 1 erhöht.

\lstinputlisting[firstline=11, lastline=24]{CodeSnippets/Befehlsuebersicht/for_schleifen.c} 

Dieses Programm berechnet für zwei Variablen \(x\) (hier \emph{basis}) und \(y\) (hier \emph{exponent}) das Ergebnis von \(x^y\).


\subsection{While-Schleife}

Die \emph{While-Schleife} setzt man immer dann ein, wenn man nicht genau weiß, wie oft die Schleife laufen soll. \emph{While-Schleifen} können so genannte \emph{Endlosschleifen} produzieren. Das sind Schleifen, die wie der Name bereits sagt, nie \emph{terminieren} sondern endlos weiter laufen.

\begin{lstlisting}[language=c]
 while(<Bedingung>){
 	<Code der mehrfach ausgefuehrt werden soll>
 }
 \end{lstlisting}

 Die Schleife wiederholt den Code solange die Bedingung wahr ist.

 \lstinputlisting[firstline=1, lastline=3]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

 Da die Bedingung \( 3 < 5 \) immer wahr ist, wird diese Schleife endlos laufen.

 \lstinputlisting[firstline=5, lastline=9]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

 Diese Schleifen multipliziert \(x\) so oft mit sich selbst, bis \(x\) größer als 10000 ist.

\lstinputlisting[firstline=11, lastline=13]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

Diese Schleife wird nicht ein einziges mal ausgeführt, da die Bedingung nie wahr ist.



\subsection{Do-While-Schleife}

Die \emph{Do-While-Schleife} verhält sich exakt wie die \emph{While-Schleife}, mit der Ausnahme, dass der Code mindestens einmal ausgeführt wird.

\begin{lstlisting}[language=c]
do{
 	<Code der mehrfach ausgefuehrt werden soll>
}while(<Bedingung>);
\end{lstlisting} 

Der Code wird so lange ausgeführt, wie die Bedingung wahr ist, mindestens aber einmal.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/do_while_schleifen.c}


\end{document}