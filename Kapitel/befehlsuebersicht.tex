\documentclass[c_worksheet.tex]{subfiles}

\begin{document}
	
\chapter{Befehlsübersicht} 

\section{Programmstruktur}

In \textbf{C} geschriebene Programme haben eine generelle Struktur die es zu beachten gibt. Diese sieht wie folgt aus

\begin{lstlisting}
 int main(){
 	<Code>
 	return 0;
 }
 \end{lstlisting} 

Die so genannte \emph{main Funktion} ist der Haupteil des Programms. Wird das Programm gestartet beginnt es genau am Anfang der \emph{main Funktion}. Gibt es keine \emph{main Funktion} weiß der Computer nicht wo er anfangen soll. \\

\textit{return 0} \\

Dieser Befehl beendet das Programm und die \emph{0} ist dabei eine Konvention, welche fest gelegt wurde. \emph{0} bedeutet hierbei, dass alles in Ordnung war und das Programm korrekt terminiert wurde. Dies wird an das Betriebssystem mitgeteilt. 



\section{Includes} 

Mit so genannten \emph{includes} kann man anderen Programmcode in sein eigenes Programm einbinden.

\begin{lstlisting}
#include <<Paketname>>
\end{lstlisting}

Ein Paket das ganz oft benutzt wird und auch benötigt wird, sobald ihr etwas ausgeben wollt, ist \emph{stdio.h}. Der name steht dabei für Standart Input/Output. Dieses Paket stellt einige nützliche Befehle für die Ein- und Ausgabe.

Die wichtigsten hierbei sind \emph{printf} und \emph{scanf}. Mit ersterem kann man Text ausgeben und mit letzterem Eingaben des Benutzers einlesen.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/print.c} 

Dieses Programm gibt auf der Konsole "Hallo Welt!" aus. Ohne den \emph{include} Befehl, wüsste der Compiler nicht was printf eigentlich ist.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/scan.c}

Dieses Programm erwartet eine Eingabe von dem Benutzer und speichert diese in der Variable \(x\). 

\section{Variablen}

In Variablen kann man Werte speichern, dafür gibt es verschiedene Typen, unter anderem:

\begin{itemize}
 	\item \textbf{int} - ganze Zahlen
 	\item \textbf{float} - Kommazahlen
 	\item \textbf{double} - Kommazahlen die doppelt so präzise sind (wie \emph{floats})
 	\item \textbf{char} - Zeichen wie z.B. 'a' oder 'b' 
 \end{itemize} 

Es gibt noch viele andere Typen für Variablen.

Variablen werden nach dem folgenden Schema angelegt

\begin{lstlisting}
<typ> <name>;
\end{lstlisting}

und können bei ihrer \emph{Initialisierung} direkt einen Wert zugewiesen bekommen.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/variablen.c} 

\subsection{Variablen mit printf ausgeben} 

Möchte man Variablen mit printf ausgeben, muss dabei beachten, von welchem Typ diese ist. Ein kleines Beispiel verdeutlicht dies.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/print_int.c}

Das \emph{\%i} wird dabei benutzt, weil \(x\) vom typ \emph{int} ist.

\begin{itemize}
	\item \textbf{\%i} - int
	\item \textbf{\%d} - int
	\item \textbf{\%ld} - long int
	\item \textbf{\%f} - float
	\item \textbf{\%lf} - double
	\item \textbf{\%c} - char
	\item \textbf{\%p} - pointer 
\end{itemize}

Für scanf gilt das genau so.

\section{Arithmetik}

In \textbf{C} gibt es viele verschiedene Arithmetische Operatoren, im folgenden einige wichtige

\begin{itemize}
 	\item \textbf{\(+\)} - Addition
 	\item \textbf{\(-\)} - Subtraktion
 	\item \textbf{\(*\)} - Multiplikation
 	\item \textbf{\(/\)} - Division
 	\item \textbf{\%} - Modulo   
 \end{itemize} 

 Diese \emph{arithmethischen Operatoren} können sowohl mit Variablen als auch mit Konstanten genutzt werden.

 \lstinputlisting{CodeSnippets/Befehlsuebersicht/arithmetik.c} 

Um das programmieren etwas zu erleichtern gibt es folgende Abkürzungen.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/arithmetik_abkuerzungen.c} 



\section{Logische Operatoren} 


Logische Operatoren unterscheiden sich ein wenig von den arithmetischen, die man sonst so kennt. Formeln mit logischen Operatoren evaluieren immer auf einen so genannten \emph{Wahrheitswert}: \textbf{true} oder \textbf{false}. Diese \emph{keywords} gibt es in \textbf{C} aber leider nicht. In \textbf{C} bedeutet die Zahl \(0\) \textbf{true} und alles andere bedeutet \textbf{false}.

Es gibt unter anderem folgende logische Operatoren in \textbf{C}

\begin{itemize}
	\item \textbf{\&\&} - logisches Und
	\item \textbf{||} - logisches Oder
	\item \textbf{\^}  - exklusives Oder
	\item \textbf{!}  - Negation
\end{itemize}

Im folgenden werden die Operatoren mit Wahrheitstabellen veranschaulicht

\begin{figure}[H]
\begin{center}
\begin{subfigure}[b]{0.2\textwidth}
\centering
\begin{tabular}{ c | c | c }
a & b & a \&\& b \\
\hline
\hline
0 & 0 & 0 \\
\hline
0 & 1 & 0 \\
\hline
1 & 0 & 0 \\
\hline
1 & 1 & 1 \\
\end{tabular}
\end{subfigure}
\begin{subfigure}[b]{0.2\textwidth}
\centering
\begin{tabular}{ c | c | c }
a & b & a || b \\
\hline
\hline
0 & 0 & 0 \\
\hline
0 & 1 & 1 \\
\hline
1 & 0 & 1 \\
\hline
1 & 1 & 1 \\
\end{tabular}
\end{subfigure}
\begin{subfigure}[b]{0.2\textwidth}
\centering
\begin{tabular}{ c | c | c }
a & b & a \^{} b \\
\hline
\hline
0 & 0 & 0 \\
\hline
0 & 1 & 1 \\
\hline
1 & 0 & 1 \\
\hline
1 & 1 & 0 \\
\end{tabular}
\end{subfigure}
\begin{subfigure}[b]{0.2\textwidth}
\centering
\begin{tabular}{ c | c }
a & !a \\
\hline
\hline
0 & 1 \\
\hline
1 & 0 \\
\end{tabular}
\end{subfigure}
\end{center}
\end{figure}


Andere Operatoren, die nicht direkt mit Wahrheitswerten arbeiten aber solche ausgeben sind z.B.

\begin{itemize}
	\item \textbf{>} - größer als
	\item \textbf{<} - kleiner als
	\item \textbf{>=} - größer gleich
	\item \textbf{<=} - kleiner gleich
	\item \textbf{==} - gleich
\end{itemize}

Diese Operatoren werden hauptsächlich bei Bedingungen verwendet

\section{Bedingungen}

Viele Programme sollen ja nicht immer gleich ablaufen, und sich verschieden verhalten, wenn bestimmte Bedingungen eintreten.

Dafür gibt es den \emph{if} Befehle, oder auch den \emph{if else} Befehl. Mit diesem können so genannte \emph{bedingte Sprünge} gemacht werden. Die Synthax sieht wie folgt aus

\begin{lstlisting}[language=c]
if(<Bedingung>){
	<Code>
}
\end{lstlisting}

Dabei wird <Code> nur ausgeführt, wenn <Bedingung> wahr ist.

Als Bedingung können beliebig komplexe Ausdrücke verwendet werden, solange sich diese auf einen \emph{Wahrheitswert} evaluieren.

Korrekte Bedingungen:

\begin{itemize}
	\item \(x > 5\)
	\item \(y == x\)
	\item \(z > x\) \&\& \(z < x\)
	\item \(a\) || \(b\)
\end{itemize}

Ungültige Bedingungen.

\begin{itemize}
	\item \(x * 4\)
	\item \(y = x\)
	\item \(x++\)
\end{itemize}

Es gibt noch eine so genannte \emph{else} Bedingung, die genau dann ausgeführt wird, wenn die Bedingung in dem \emph{if} Befehl falsch ist.

\begin{lstlisting}[language=c]
if(<Bedingung>){
	<Code der ausgefuehrt wird wenn die Bedingung stimmt>
}
else{
	<Code der ausgefuehrt wird wenn die Bedingung nicht stimmt>
}
\end{lstlisting}

Damit lassen sich Programme basteln, die sich verschieden Verhalten, je nachdem wie die Umstände so sind.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/Bedingungen.c}



\section{Schleifen} 

Manchmal möchte man, dass ein Stück Code mehrfach ausgeführt wird. Geht es nur um 2 oder 3 mal, könnte man das ganze auch einfach mehrfach hinschreiben. Wenn es dann aber um 100, 1000 oder gar 10000 fach geht, macht das ganze eher weniger Spaß. Dazu kommt, dass man oft nicht weiß, wie oft der Code Teil ausgeführt wird.

Die Bedingungen werden dabei exakt wie bei dem \emph{if} Befehl aufgestellt.

Für solche Fälle gibt es so genannte \emph{Schleifen}. \textbf{C} bietet drei verschiedene.

\subsection{For-Schleife}

Die \emph{For-Schleife} verwendet man, wenn man ein Stück Code eine feste Anzahl oft ausführen möchte. Die Anzahl kann dabei variable sein, jedoch fest. \emph{For-Schleifen} nutzen so genannte \emph{Laufvariablen} mit denen man von einem \emph{Startwert} bis zu einem \emph{Endwert} läuft.

\begin{lstlisting}[language=c]
for(<Startwert> ; <Abbruchbedingung> ; <Veraenderung>){
	<Code der mehrfach ausgefuehrt werden soll>
}
\end{lstlisting}

In den so genannten \emph{Kopf} einer \emph{For-Schleife} schreibt man den Wert, bei dem die Zählvarible beginnen soll, die Bedingung bei der aus der Schleife ausgebrochen werden soll und die Art, wie die \emph{Laufvariable} in jedem \emph{Schleifendurchlauf} verändet werden soll.

\lstinputlisting[firstline=1, lastline=9]{CodeSnippets/Befehlsuebersicht/for_schleifen.c} 

Das Programm gibt 10 mal den Wert von \(i\) aus. \(i\) wird dabei in jedem \emph{Schleifendurchlauf} um 1 erhöht.

\lstinputlisting[firstline=11, lastline=24]{CodeSnippets/Befehlsuebersicht/for_schleifen.c} 

Dieses Programm berechnet für zwei Variablen \(x\) (hier \emph{basis}) und \(y\) (hier \emph{exponent}) das Ergebnis von \(x^y\).


\subsection{While-Schleife}

Die \emph{While-Schleife} setzt man immer dann ein, wenn man nicht genau weiß, wie oft die Schleife laufen soll. \emph{While-Schleifen} können so genannte \emph{Endlosschleifen} produzieren. Das sind Schleifen, die wie der Name bereits sagt, nie \emph{terminieren} sondern endlos weiter laufen.

\begin{lstlisting}[language=c]
 while(<Bedingung>){
 	<Code der mehrfach ausgefuehrt werden soll>
 }
 \end{lstlisting}

 Die Schleife wiederholt den Code solange die Bedingung wahr ist.

 \lstinputlisting[firstline=1, lastline=3]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

 Da die Bedingung \( 3 < 5 \) immer wahr ist, wird diese Schleife endlos laufen.

 \lstinputlisting[firstline=5, lastline=9]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

 Diese Schleifen multipliziert \(x\) so oft mit sich selbst, bis \(x\) größer als 10000 ist.

\lstinputlisting[firstline=11, lastline=13]{CodeSnippets/Befehlsuebersicht/while_schleifen.c} 

Diese Schleife wird nicht ein einziges mal ausgeführt, da die Bedingung nie wahr ist.



\subsection{Do-While-Schleife}

Die \emph{Do-While-Schleife} verhält sich exakt wie die \emph{While-Schleife}, mit der Ausnahme, dass der Code mindestens einmal ausgeführt wird.

\begin{lstlisting}[language=c]
do{
 	<Code der mehrfach ausgefuehrt werden soll>
}while(<Bedingung>);
\end{lstlisting} 

Der Code wird so lange ausgeführt, wie die Bedingung wahr ist, mindestens aber einmal.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/do_while_schleifen.c}



\section{Funktionen}

Manchmal hat man ein Stück Code geschrieben und möchte es an mehreren Stellen verwenden. Dann kann man das ganze natürlich mehrfach schreiben, aber sinnvoller ist es eine Funktion zu verwenden. Eine Funktion wird wie folgt definiert

\begin{lstlisting}[language=c]
<Rueckgabetyp> <name>(<Typ> <p1Name>, .. , <Typ> <pnName>){
	<FunktionsCode>
}
\end{lstlisting}

Der \emph{Rückgabetyp} bezeichnet dabei den Typ des Wertes, den die Funktion am Ende zurück gibt. Also so etwas wie \emph{int}, \emph{float} oder auch \emph{char}. Möchte man nichts zurück geben, ist der \emph{Rückgabetyp} \textbf{void}.

Mit dem \emph{Funktionsnamen} kann man die Funktion später aufrufen.

Mit den \emph{Parametern} kann man der Funktion Werte übergeben. Jedem von ihnen wird ein \emph{Typ} und ein \emph{Parametername} zugeordnet. Mit diesem \emph{Parametername} kann man in der Funktion auf diese Variable zugreifen.

Mit dem Befehel \emph{return} beendet man die Funktion und gibt den Wert zurück, den man zusammen mit dem \emph{return} Befehl angibt, zurück.


\lstinputlisting[firstline=1, lastline=3]{CodeSnippets/Befehlsuebersicht/funktionen_addition.c} 

Die Funktion hat den namen \"addition\", gibt einen Wert vom Typ \textbf{int} zurück, bekommt 2 Parameter vom Typ \emph{int} mit dem Namen \(a\) und \(b\) und berechnet deren Summe. Diese wird mit dem \emph{return} Befehl zurück gegeben.

Die Funktion kann dann ganz einfach in der \emph{main} Funktion aufgerufen werden.

\lstinputlisting[firstline=5, lastline=21]{CodeSnippets/Befehlsuebersicht/funktionen_addition.c} 

Mit den \emph{Parameternamen} kann innerhalb der Funktion auf diese zugegriffen werden. Wichtig dabei ist, dass diese Parameter nur in der Funktion selbst sichtbar (das heißt benutzbar) sind.

Alle Variablen die innerhalb einer Funktion \emph{initialisiert} werden, sind nur dort sichtbar und verwendbar. Es kann durchaus mehrere Variablen mit gleichem Namen geben.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/funktionen_sichtbarkeit.c} 

Funktionen können beliebig komplex werden. Folgende Funktion berechnet zum Beispiel die Fakultät einer Zahl.

\lstinputlisting{CodeSnippets/Befehlsuebersicht/funktionen_fakultaet.c} 

\end{document}